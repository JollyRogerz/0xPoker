{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/zeroxPoker.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n\r\ncontract zeroxPoker is Ownable {\r\n\r\n    address public deployer;\r\n\r\n    constructor(address initialOwner) {\r\n\t\tsuper.transferOwnership(initialOwner);\r\n        deployer = initialOwner;\r\n\t}\r\n\r\n    // 4 Game Phases: Join, Commit, Reveal, Result\r\n    enum GameState {\r\n        JoinPhase,\r\n        CommitPhase,\r\n        RevealPhase,\r\n        ResultPhase\r\n    }\r\n    // 3 Game Results: P1 win, P2 win, draw\r\n    enum GameResult {\r\n        P1Win,\r\n        P2Win,\r\n        Draw\r\n    }\r\n    // Store the hashes for each hand easy comparison\r\n    bytes32 royalFlushHash = keccak256(abi.encodePacked(\"Royal Flush\"));\r\n    bytes32 straightFlushHash = keccak256(abi.encodePacked(\"Straight Flush\"));\r\n    bytes32 fourOfAKindHash = keccak256(abi.encodePacked(\"Four of a Kind\"));\r\n    bytes32 fullHouseHash = keccak256(abi.encodePacked(\"Full House\"));\r\n    bytes32 flushHash = keccak256(abi.encodePacked(\"Flush\"));\r\n    bytes32 straightHash = keccak256(abi.encodePacked(\"Straight\"));\r\n    bytes32 threeOfAKindHash = keccak256(abi.encodePacked(\"Three of a Kind\"));\r\n    bytes32 twoPairsHash = keccak256(abi.encodePacked(\"Two Pairs\"));\r\n    bytes32 onePairHash = keccak256(abi.encodePacked(\"One Pair\"));\r\n    bytes32 noSequenceHash = keccak256(abi.encodePacked(\"No Sequence\"));\r\n\r\n    // Holds the game data for a single match\r\n    struct GameStruct {\r\n        bool initialized;\r\n        address player1;\r\n        address player2;\r\n        GameState gameState;\r\n        bytes32 commit1;\r\n        bytes32 commit2;\r\n        bytes32 reveal1;\r\n        bytes32 reveal2;\r\n        uint256 revealDeadline;\r\n        uint256 betAmount;\r\n        GameResult gameResult;\r\n    }\r\n        \r\n        uint256 public totalBalance;\r\n\r\n\r\n    // Maps Game address => Game data\r\n    mapping(address => GameStruct) public games;\r\n    // Maps Player address to their current 'active' game\r\n    mapping(address => address) public activeGame;\r\n    //Checks if a player has already commited \r\n    mapping(address => mapping(address => bool)) public hasCommitted;\r\n\r\n    /**\r\n     * @notice Modifier that checks game is initialized, the sender is player 1/2\r\n     * and that the game state to be in the expected phase\r\n     * @param gameHash - the game code\r\n     * @param gameState - the three possible game phases\r\n     */\r\n    modifier validGameState(address gameHash, GameState gameState) {\r\n        // Check that the game exists\r\n        require(\r\n            games[gameHash].initialized == true,\r\n            \"Game code does not exist\"\r\n        );\r\n        // Check player is either player 1 or player 2\r\n        require(\r\n            games[gameHash].player1 == msg.sender ||\r\n                games[gameHash].player2 == msg.sender,\r\n            \"Player not in this game\"\r\n        );\r\n        // Check that game is in expected state\r\n        require(\r\n            games[gameHash].gameState == gameState,\r\n            \"Game not in correct phase\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new game, generating a game hash and setting player 1 as sender\r\n     *  and player 2 as the address provided\r\n     * @param otherPlayer - address for player 2\r\n     */\r\n    function createGame(address otherPlayer) public returns (address) {\r\n        //\r\n        address gameHash = generateGameHash();\r\n        require(\r\n            !games[gameHash].initialized,\r\n            \"Game code already exists, please try again\"\r\n        );\r\n        // Check other player isn't host\r\n        require(\r\n            msg.sender != otherPlayer,\r\n            \"Invited player must have a different address\"\r\n        );\r\n\r\n        games[gameHash].initialized = true;\r\n        games[gameHash].player1 = msg.sender;\r\n        games[gameHash].player2 = otherPlayer;\r\n\r\n        // Set game phase to initial join phase\r\n        games[gameHash].gameState = GameState.JoinPhase;\r\n\r\n        // Set P1 active game to game hash\r\n        activeGame[msg.sender] = gameHash;\r\n\r\n        // Return the game hash so it can be shared\r\n        return gameHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Function for player 2 to join a game with the game address\r\n     * @param gameHash - game address shared by player 1\r\n     */\r\n    function joinGame(address gameHash)\r\n        public\r\n        validGameState(gameHash, GameState.JoinPhase)\r\n    {\r\n        // Set game phase to commit phase\r\n        games[gameHash].gameState = GameState.CommitPhase;\r\n\r\n        // Set P2 active game to game hash\r\n        activeGame[msg.sender] = gameHash;\r\n    }\r\n\r\n    \r\n    function commit(string memory pokerHand, string memory salt)\r\n        public\r\n        payable\r\n        validGameState(activeGame[msg.sender], GameState.CommitPhase)\r\n    {\r\n        // Get the game hash from active game mapping\r\n        address gameHash = activeGame[msg.sender];\r\n\r\n        require(!hasCommitted[msg.sender][gameHash], \"Player has already committed\");\r\n\r\n        bytes32 unsaltedPokerHandHash = keccak256(abi.encodePacked(pokerHand));\r\n\r\n        // Check if choice  is valid \r\n        require(\r\n                unsaltedPokerHandHash == royalFlushHash ||\r\n                unsaltedPokerHandHash == straightFlushHash ||\r\n                unsaltedPokerHandHash == fullHouseHash ||\r\n                unsaltedPokerHandHash == fourOfAKindHash ||\r\n                unsaltedPokerHandHash == flushHash ||\r\n                unsaltedPokerHandHash == straightHash ||\r\n                unsaltedPokerHandHash == threeOfAKindHash ||\r\n                unsaltedPokerHandHash == twoPairsHash ||\r\n                unsaltedPokerHandHash == onePairHash ||\r\n                unsaltedPokerHandHash == noSequenceHash,\r\n                    \"Invalid poker hand\"\r\n        );\r\n\r\n        // Generate commit hash with pokerHand + user chosen salt\r\n        bytes32 commitHash = keccak256(abi.encodePacked(pokerHand, salt));\r\n\r\n        bool isPlayer1 = games[gameHash].player1 == msg.sender;\r\n        if (isPlayer1) {\r\n            games[gameHash].commit1 = commitHash;\r\n        } else {\r\n            games[gameHash].commit2 = commitHash;\r\n        }\r\n\r\n        // Mark the player as having committed\r\n        hasCommitted[msg.sender][gameHash] = true;  \r\n\r\n        // Store the amount of ether sent with the commit\r\n        games[gameHash].betAmount = msg.value;\r\n        totalBalance += msg.value;\r\n\r\n\r\n        // If both player have committed, set game state to reveal phase\r\n        if (games[gameHash].commit1 != 0 && games[gameHash].commit2 != 0) {\r\n            games[gameHash].gameState = GameState.RevealPhase;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Function for players to reveal their choice. The first player to reveal sets a deadline for the second player\r\n     * this is prevent players for abandoning the game once they know they have lost based on the revealed hash.\r\n     * At the end of the deadline, the player who committed can trigger a \"win-by-default\".\r\n     * If both players reveal in time, the second player's reveal will call determineWinner() and advance the game to the result phase\r\n     * @notice Unlike commit, players can only reveal once\r\n     * @param salt - a player chosen secret string from the \"commit\" phase used to prove their choice via a hash match\r\n     */\r\n    function reveal(string memory salt)\r\n        public\r\n        validGameState(activeGame[msg.sender], GameState.RevealPhase)\r\n    {\r\n        // Get the game hash from active game mapping\r\n        address gameHash = activeGame[msg.sender];\r\n\r\n        bool isPlayer1 = games[gameHash].player1 == msg.sender;\r\n        // Check that player hasn't already revealed\r\n        if (isPlayer1) {\r\n            require(games[gameHash].reveal1 == 0, \"Already revealed\");\r\n        } else {\r\n            require(games[gameHash].reveal2 == 0, \"Already revealed\");\r\n        }\r\n\r\n        // Verify that one of the pokerHands + salt hashes matches commit hash\r\n        // Compare all nine possible pokerHands so they don't have to enter their choice again\r\n\r\n        bytes32 verificationHashroyalFlush = keccak256(abi.encodePacked(\"Royal Flush\", salt));\r\n        bytes32 verificationHashstraightFlush  = keccak256(abi.encodePacked(\"Straight Flush\", salt));\r\n        bytes32 verificationHashfourOfAKind  = keccak256(abi.encodePacked(\"Four of a Kind\", salt));\r\n        bytes32 verificationHashfullHouse  = keccak256(abi.encodePacked(\"Full House\", salt));\r\n        bytes32 verificationHashflush  = keccak256(abi.encodePacked(\"Flush\", salt));\r\n        bytes32 verificationHashstraight  = keccak256(abi.encodePacked(\"Straight\", salt));\r\n        bytes32 verificationHashthreeOfAKind  = keccak256(abi.encodePacked(\"Three of a Kind\", salt));\r\n        bytes32 verificationHashtwoPairs  = keccak256(abi.encodePacked(\"Two Pairs\", salt));\r\n        bytes32 verificationHashonePair  = keccak256(abi.encodePacked(\"One Pair\", salt));\r\n        bytes32 verificationHashnoSequence  = keccak256(abi.encodePacked(\"No Sequence\", salt));\r\n\r\n        bytes32 commitHash = isPlayer1 ? games[gameHash].commit1 : games[gameHash].commit2;\r\n\r\n        require(\r\n                verificationHashroyalFlush == commitHash ||\r\n                verificationHashstraightFlush == commitHash ||\r\n                verificationHashfourOfAKind == commitHash ||\r\n                verificationHashfullHouse == commitHash ||\r\n                verificationHashflush == commitHash ||\r\n                verificationHashstraight == commitHash ||\r\n                verificationHashthreeOfAKind == commitHash ||\r\n                verificationHashtwoPairs == commitHash ||\r\n                verificationHashonePair == commitHash ||\r\n                verificationHashnoSequence == commitHash,\r\n            \"Reveal hash doesn't match commit hash. Salt not the same as commit.\"\r\n        );\r\n        // Work backwards to infer their pokerHand\r\n        string memory pokerHand;\r\n        if (verificationHashroyalFlush == commitHash) {\r\n            pokerHand = \"Royal Flush\";\r\n        } else if (verificationHashstraightFlush == commitHash) {\r\n            pokerHand = \"Straight Flush\";\r\n        } else if (verificationHashfourOfAKind == commitHash) {\r\n            pokerHand = \"Four of a Kind\";\r\n        } else if (verificationHashfullHouse == commitHash) {\r\n            pokerHand = \"Full House\";\r\n        } else if (verificationHashflush == commitHash) {\r\n            pokerHand = \"Flush\";\r\n        } else if (verificationHashstraight == commitHash) {\r\n            pokerHand = \"Straight\";\r\n        } else if (verificationHashthreeOfAKind == commitHash) {\r\n            pokerHand = \"Three of a Kind\";\r\n        } else if (verificationHashtwoPairs == commitHash) {\r\n            pokerHand = \"Two Pairs\";\r\n        } else if (verificationHashonePair == commitHash) {\r\n            pokerHand = \"One Pair\";\r\n        } else {\r\n            pokerHand = \"No Sequence\";\r\n        }\r\n\r\n        // Save the revealed hash w/o salt\r\n        if (isPlayer1) {\r\n            games[gameHash].reveal1 = keccak256(abi.encodePacked(pokerHand));\r\n        } else {\r\n            games[gameHash].reveal2 = keccak256(abi.encodePacked(pokerHand));\r\n        }\r\n        // if both players revealed, determine winner\r\n        if (games[gameHash].reveal1 != 0 && games[gameHash].reveal2 != 0) {\r\n            games[gameHash].gameResult = determineWinner(\r\n                games[gameHash].reveal1,\r\n                games[gameHash].reveal2\r\n            );\r\n            games[gameHash].gameState = GameState.ResultPhase;\r\n        } else {\r\n            // Set deadline for other player to reveal\r\n            games[gameHash].revealDeadline = block.timestamp + 3 minutes;\r\n        }\r\n    }\r\n    /**\r\n     * @notice Escape function if a player does not reveal in time. The other player\r\n     * can call this function to trigger a \"win-by-default\"\r\n     */\r\n    function determineDefaultWinner()\r\n        public\r\n        validGameState(activeGame[msg.sender], GameState.RevealPhase)\r\n    {\r\n        // Get the game hash from active game mapping\r\n        address gameHash = activeGame[msg.sender];\r\n        games[gameHash].gameResult = determineWinner(\r\n            games[gameHash].reveal1,\r\n            games[gameHash].reveal2\r\n        );\r\n        games[gameHash].gameState = GameState.ResultPhase;\r\n        distributeWinnings();\r\n        leaveGame();\r\n    }\r\n    /**\r\n     * @notice Players can use this to leave the game at anytime. Usually at the end to reset the UI\r\n     */\r\n    function leaveGame() public {\r\n        activeGame[msg.sender] = address(0);\r\n    }\r\n    /// @notice Util Functions for generating hashes, computing winners and fetching data\r\n    function generateGameHash() public view returns (address) {\r\n        bytes32 prevHash = blockhash(block.number - 1);\r\n        // Game hash is a pseudo-randomly generated address from last blockhash + p1\r\n        return\r\n            address(bytes20(keccak256(abi.encodePacked(prevHash, msg.sender))));\r\n    }\r\n    /**\r\n     * @notice Determine the winner based on reveals for p1 and p2\r\n     * If only 1 has revealed, they win by default\r\n     * @param revealP1 - p1's reveal, defaults to 0 if not set\r\n     * @param revealP2 - p2's reveal, defaults to 0 if not set\r\n     */\r\n    function determineWinner(bytes32 revealP1, bytes32 revealP2)\r\n        public\r\n        view\r\n        returns (GameResult)\r\n    {\r\n        // If both players have revealed, determine the winner\r\n        if (revealP1 != 0 && revealP2 != 0) {\r\n            if (revealP1 == revealP2) {\r\n                return GameResult.Draw;\r\n            }\r\n            if (revealP1 == royalFlushHash) {\r\n                if (revealP2 == straightFlushHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == fourOfAKindHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == fullHouseHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == flushHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == straightHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == threeOfAKindHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == twoPairsHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == onePairHash) {\r\n                    return GameResult.P1Win;\r\n                } else if (revealP2 == noSequenceHash) {\r\n                    return GameResult.P1Win;\r\n                }\r\n        } else if (revealP1 == straightFlushHash) {\r\n           if (revealP2 == fourOfAKindHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == fullHouseHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == flushHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == straightHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == threeOfAKindHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == twoPairsHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == onePairHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == fourOfAKindHash) {\r\n           if (revealP2 == fullHouseHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == flushHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == straightHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == threeOfAKindHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == twoPairsHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == onePairHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == fullHouseHash) {\r\n           if (revealP2 == flushHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == straightHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == threeOfAKindHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == twoPairsHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == onePairHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == flushHash) {\r\n           if (revealP2 == straightHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == threeOfAKindHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == twoPairsHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == onePairHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == straightHash) {\r\n           if (revealP2 == threeOfAKindHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == twoPairsHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == onePairHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == threeOfAKindHash) {\r\n           if (revealP2 == twoPairsHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == onePairHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == twoPairsHash) {\r\n           if (revealP2 == onePairHash) {\r\n                return GameResult.P1Win;\r\n            } else if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == onePairHash) {\r\n           if (revealP2 == noSequenceHash) {\r\n                return GameResult.P1Win;\r\n            } else {\r\n                return GameResult.P2Win;\r\n            }\r\n        } else if (revealP1 == noSequenceHash) {\r\n            return GameResult.P2Win;\r\n            }\r\n        }\r\n     \r\n        // Else the winner by default is the player that has revealed\r\n        else if (revealP1 != 0) {\r\n            return GameResult.P1Win;\r\n        } else {\r\n            return GameResult.P2Win;\r\n        }\r\n    }\r\n\r\n    function distributeWinnings() public {\r\n    \r\n        address gameHash = activeGame[msg.sender];\r\n        games[gameHash].gameState = GameState.ResultPhase; \r\n\r\n        // If the game has reached the ResultPhase\r\n        if (games[gameHash].gameState == GameState.ResultPhase) {\r\n            // Determine the winner\r\n            address winner;\r\n            address winner2;\r\n\r\n            // Calculate the total winnings\r\n            uint256 totalPot = totalBalance;\r\n            uint256 deployerCutWinnings = totalPot *  5 /  100; // Calculate  5% of Winnings\r\n            uint256 winnings = totalBalance - deployerCutWinnings; \r\n\r\n            uint256 halfWinnings = winnings/2;\r\n\r\n\r\n            //Determine Winner and send prize\r\n            if (games[gameHash].gameResult == GameResult.P1Win) {\r\n                winner = games[gameHash].player1;\r\n                payable(winner).transfer(winnings);\r\n                payable(deployer).transfer(deployerCutWinnings);\r\n            } \r\n            else if (games[gameHash].gameResult == GameResult.P2Win) {\r\n                winner = games[gameHash].player2;\r\n                payable(winner).transfer(winnings);\r\n                payable(deployer).transfer(deployerCutWinnings);\r\n            } \r\n            else if (games[gameHash].gameResult == GameResult.Draw) {\r\n                winner = games[gameHash].player1;\r\n                winner2 = games[gameHash].player2;\r\n                payable(winner).transfer(halfWinnings);\r\n                payable(winner2).transfer(halfWinnings);\r\n                payable(deployer).transfer(deployerCutWinnings);\r\n            }\r\n\r\n            // Reset the game state and bet amount\r\n            // games[gameHash].gameState = GameState.JoinPhase;\r\n            // games[gameHash].initialized = false;\r\n            games[gameHash].betAmount = 0;\r\n            totalBalance = 0;\r\n            leaveGame();\r\n        }\r\n    }\r\n    /**\r\n     * @notice Fetches the game data of the player's active game\r\n     * @param player - address of player\r\n     */\r\n    function getActiveGameData(address player)\r\n        public\r\n        view\r\n        returns (GameStruct memory)\r\n    {\r\n        // Get the game hash from active game mapping\r\n        address gameHash = activeGame[player];\r\n        return games[gameHash];\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}